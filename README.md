# AmpGen
AmpGen is a library and set of applications for fitting and generating multi-body particle decays using the isobar model.
It developed out of the MINT project used in the fitting of three and four-body pseudoscalar decays by the CLEO-c and LHCb colloborations. 

Source code is dynamically generated by a custom engine, JIT compiled and dynamically linked to the user programmer at runtime to give high performance and flexible evaluation of amplitudes. 

## Installation

### Requirements 


AmpGen is built using cmake. It is recommended to use a build directory to keep the source tree clean. 

```shell
mkdir build
cd build
cmake ..
make
```
This will build the shared library, several standalone test applications, and a set of unit tests. 

### LLVM

You can also build AmpGen with LLVM. The only change you might want when using Apple LLVM
is to specifically specify the location of the build tool for AmpGen's JIT:

```shell
-DAMPGEN_CXX=$(which c++)
```

### Usage with ROOT

The library can be used interactively in conjunction with the ROOT C++ interpretter by adding the following lines 
to the users root login script 

```
  gSystem->Load("path_to_ampgen/build/lib/libAmpGen.so");
  gROOT->ProcessLine(".include path_to_ampgen");
```

### CentOS7

In order to build stand-alone on CentOS7, you will need a valid development environment; the following line will work:

```shell
lb-run ROOT $SHELL
```

## Getting started

Several examples of usages of the library are included in the apps directory and are 
built alongside the library. 
All standalone programs can accept both options files and command line arguments. 
They also support `--help` to print help for key arguments to the program. 
This will also run the program, as arguments can be defined throughout each of the programs rather than all defined at the beginning. 

### Options files and decay descriptors 

Options files will generally contain the description of one or more particle decays,
as well as other settings such as input/output locations, global flags such as 
whether complex numbers should be interpretted as cartesian or polar, and other parameters 
such as the masses and widths of particles is these differ from those given in the PDG.
 
A minimal example options file for the generator application could contain: 
```
EventType D0 K+ pi- pi- pi+
#                                           Real / Amplitude   | Imaginary / Phase 
#                                           Fix?  Value  Step  | Fix?  Value  Step
D0{K*(892)0{K+,pi-},rho(770)0{pi+,pi-}}     2     1      0       2     0      0   
```
The EventType specifies the initial and final states requested by the user. 
This gives the ordering of particles used in input data, in output code, and used in internal computations. 
This also defines how the amplitude source code must be interfaced with external packages, i.e. MC generators such as EvtGen.

The decay products of a particle are enclosed within curly braces, for example
```
K*(892)0{K+,pi-}
```
describes an excited vector kaon decaying into a charged kaon and pion. 
The other numbers on the lines that describe the decays parameterise the coupling to this channel, 
either in terms of real and imaginary parts or an amplitude and a phase. 
These options can be used in the Generator application, which is described below. 

### Generator

The standalone generator for models can be used as

```shell
./Generator MyOpts.opt --nEvents=1000 --output=output.root
```

Which generates 1000 events of the model described in MyOpts.opt and saves them to output.root.

### ConvertToSourceCode

This produces source code to evalute the PDF, and normalises for use with other generators such as EvtGen, i.e. P(max) < 1. This can be used as

```shell
./ConvertToSourceCode MyOpts.opt --sourceFile=MyFile.cpp
```

This can then be a compiled to a shared library using

```shell
g++ -Ofast -shared -rdynamic --std=c++14 -fPIC MyFile.cpp -o MyFile.so
```

<!---
(I broke the python bindings and haven't got round to fixing them yet, hence commented out of the instructions)
You can then check the file by opening it it Python3, using the utility class provided:

```python
from ampgen import FixedLib
lib = FixedLib('MyModel.so')
print(lib.matrix_elements[0]) # Print first matrix element

import pandas as pd
model = pd.read_csv('Input.csv', nrows=100_000)
fcn1 = lib.FCN_all(model)

# or, a bit slower, but just to show flexibility:
fcn2 = model.apply(lib.FCN, axis=1)
```

In this example, I've converted the output to csv to make it easy to import in Python without ROOT present. `.matrix_elements` gives you access to the parts of the PDF, with a `.amp` function that you can feed with P and E (`.vars` holds the current values).
-->

### Fitter
### Debugger
### DataConverter

